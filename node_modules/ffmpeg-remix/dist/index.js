'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (data, callback) {
  var tmpDir = _tmp2.default.dirSync({
    unsafeCleanup: true
  });

  if (data.limit) {
    _async2.default.mapLimit(data.input, data.limit, ingest(data, tmpDir), concat(data, tmpDir, callback));
  } else {
    _async2.default.map(data.input, ingest(data, tmpDir), concat(data, tmpDir, callback));
  }
};

var _async = require('async');

var _async2 = _interopRequireDefault(_async);

var _fluentFfmpeg = require('fluent-ffmpeg');

var _fluentFfmpeg2 = _interopRequireDefault(_fluentFfmpeg);

var _tmp = require('tmp');

var _tmp2 = _interopRequireDefault(_tmp);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var d = (0, _debug2.default)('ffmpeg-remix');
_tmp2.default.setGracefulCleanup();

var ingest = function ingest(data, tmpDir) {
  if (data.ffmpegPath) {
    _fluentFfmpeg2.default.setFfmpegPath(data.ffmpegPath);
  }
  return function (input, callback) {
    var ff = (0, _fluentFfmpeg2.default)(input.source);

    if (input.start) {
      ff.seekInput(input.start);
    } else {
      input.start = 0;
    }

    if (input.end) input.duration = input.end - input.start;
    if (input.duration) ff.duration(input.duration);

    input.path = _tmp2.default.fileSync({
      dir: tmpDir.name,
      prefix: 'ingest-',
      postfix: '.ts'
    }).name;

    ff.audioCodec('copy').videoCodec('copy');
    ff.output(input.path);

    ff.on('start', function (commandLine) {
      d('Spawned: ' + commandLine);
    });

    ff.on('error', function (err, stdout, stderr) {
      d(err);
      callback(err, null);
    });

    ff.on('end', function () {
      d('Created: ' + input.path);
      callback(null, input);
    });

    ff.run();
  };
};

var concat = function concat(data, tmpDir, callback) {
  if (data.ffmpegPath) {
    _fluentFfmpeg2.default.setFfmpegPath(data.ffmpegPath);
  }
  return function (err, ingest) {
    var ff = (0, _fluentFfmpeg2.default)();

    var input = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = ingest[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var segment = _step.value;

        input.push(segment.path);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    ff.input('concat:' + input.join('|'));
    ff.output(data.output);

    ff.on('start', function (commandLine) {
      d('Spawned: ' + commandLine);
    });

    ff.on('error', function (err, stdout, stderr) {
      d(err);
      tmpDir.removeCallback();
      callback(err);
    });

    ff.on('end', function () {
      d('Created: ' + data.output);
      tmpDir.removeCallback();
      callback(null, data);
    });

    ff.run();
  };
};

module.exports = exports['default'];